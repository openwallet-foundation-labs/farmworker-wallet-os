// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import "mx-global";
import { Big } from "big.js";

// BEGIN EXTRA CODE
import "../shim.js";
import support from "../support/entidad";
//import crypto from "crypto";
import { KeyDerivationMethod } from '@credo-ts/core';
import { DidCommMimeType } from '@credo-ts/core';
import { AutoAcceptCredential } from '@credo-ts/core';
import { AutoAcceptProof } from '@credo-ts/core';
import { MediatorPickupStrategy } from '@credo-ts/core';
import { ConsoleLogger, LogLevel } from '@credo-ts/core';
import { Agent } from '@credo-ts/core'
import { ConnectionsModule } from '@credo-ts/core';
import { V2CredentialProtocol } from '@credo-ts/core';
import { KeyDidRegistrar } from '@credo-ts/core';
import { JwkDidRegistrar } from '@credo-ts/core';
import { WebDidResolver } from '@credo-ts/core';
import { KeyDidResolver } from '@credo-ts/core';
import { JwkDidResolver } from '@credo-ts/core';
import { MediationRecipientModule } from '@credo-ts/core';
import { DidsModule } from '@credo-ts/core';
import { V2ProofProtocol } from '@credo-ts/core';
import { CredentialsModule } from '@credo-ts/core';
import { ProofsModule } from '@credo-ts/core';
import { V1CredentialProtocol } from '@credo-ts/anoncreds';
import { V1ProofProtocol } from '@credo-ts/anoncreds';
import { LegacyIndyCredentialFormatService } from '@credo-ts/anoncreds';
import { LegacyIndyProofFormatService } from '@credo-ts/anoncreds';
import { AnonCredsProofFormatService } from '@credo-ts/anoncreds';
import { AnonCredsCredentialFormatService } from '@credo-ts/anoncreds';
import { AnonCredsModule } from '@credo-ts/anoncreds';
import { IndyVdrAnonCredsRegistry } from '@credo-ts/indy-vdr';
import { IndyVdrIndyDidResolver } from '@credo-ts/indy-vdr';
import { IndyVdrSovDidResolver } from '@credo-ts/indy-vdr';
import { IndyVdrModule } from '@credo-ts/indy-vdr';
import { agentDependencies } from '@credo-ts/react-native'
import { AskarModule } from '@credo-ts/askar'
import { OpenId4VcHolderModule } from '@credo-ts/openid4vc';
import { anoncreds } from '@hyperledger/anoncreds-react-native';
import { indyVdr } from '@hyperledger/indy-vdr-react-native';
import { ariesAskar } from '@hyperledger/aries-askar-react-native'
import { QuestionAnswerModule } from '@credo-ts/question-answer';
import { DrpcModule } from '@credo-ts/drpc';
import { SurveyModule } from '@entidad/credo-ts-survey';
import { UserProfileModule } from 'credo-ts-user-profile'
import { MediaSharingModule } from 'credo-ts-media-sharing';//https://github.com/2060-io/credo-ts-media-sharing
import { DidWebAnonCredsRegistry } from 'credo-ts-didweb-anoncreds';
import { ReceiptsModule } from '@2060.io/credo-ts-didcomm-receipts'; //https://github.com/2060-io/credo-ts-didcomm-ext

// END EXTRA CODE

/**
 * Constructs a new Agent object based on configuration options given
 * Caches constructed object in the running javascript context
 * Returns a string value, the walletConfig id, that can be used to perform further operations on the constructed Agent object
 * @param {string} label
 * @param {string} walletConfig_id
 * @param {string} walletConfig_key
 * @param {"Agent_SDK.enum_aries_KeyDerivationMethod.Argon2IMod"|"Agent_SDK.enum_aries_KeyDerivationMethod.Argon2Int"|"Agent_SDK.enum_aries_KeyDerivationMethod.Raw"} walletConfig_KeyDerivationMethod
 * @param {string} walletConfig_storage
 * @param {string} endpoints
 * @param {string} publicDidSeed
 * @param {boolean} connectToIndyLedgerOnStartup
 * @param {"Agent_SDK.enum_aries_Logger.Console"|"Agent_SDK.enum_aries_Logger.DefaultLogger"} logger
 * @param {"Agent_SDK.enum_aries_Loglevel.debug"|"Agent_SDK.enum_aries_Loglevel.error"|"Agent_SDK.enum_aries_Loglevel.fatal"|"Agent_SDK.enum_aries_Loglevel.info"|"Agent_SDK.enum_aries_Loglevel.off"|"Agent_SDK.enum_aries_Loglevel.test"|"Agent_SDK.enum_aries_Loglevel.trace"|"Agent_SDK.enum_aries_Loglevel.warn"} loglevel
 * @param {"Agent_SDK.enum_aries_DidCommMimeType.v0"|"Agent_SDK.enum_aries_DidCommMimeType.v1"} didCommMimeType
 * @param {"Agent_SDK.enum_aries_AutoAcceptCredential.Never"|"Agent_SDK.enum_aries_AutoAcceptCredential.ContentApproved"|"Agent_SDK.enum_aries_AutoAcceptCredential.Always"} autoAcceptCredentials
 * @param {"Agent_SDK.enum_aries_AutoAcceptProof.Never"|"Agent_SDK.enum_aries_AutoAcceptProof.ContentApproved"|"Agent_SDK.enum_aries_AutoAcceptProof.Always"} autoAcceptProofs
 * @param {boolean} autoAcceptMediationRequests
 * @param {string} mediationConnectionsInvitation
 * @param {string} defaultMediatorId
 * @param {boolean} clearDefaultMediator
 * @param {Big} mediatorPollingInterval
 * @param {"Agent_SDK.enum_aries_MediatorPickupStrategy.PickUpV1"|"Agent_SDK.enum_aries_MediatorPickupStrategy.PickUpV2"|"Agent_SDK.enum_aries_MediatorPickupStrategy.Implicit"|"Agent_SDK.enum_aries_MediatorPickupStrategy.None"} mediatorPickupStrategy
 * @param {Big} maximumMessagePickup
 * @param {boolean} useLegacyDidSovPrefix
 * @param {string} connectionImageUrl
 * @param {boolean} autoUpdateStorageOnStartup
 * @param {boolean} autoAcceptConnections
 * @param {string} indyLedgers - optional json
 * @param {boolean} useDidSovPrefixWhereAllowed
 * @param {boolean} useDidKeyInProtocols
 * @param {boolean} useModuleOpenId4VC
 * @param {boolean} v1ProofProtocol
 * @param {boolean} v2ProofProtocol
 * @param {boolean} v1CredentialProtocol
 * @param {boolean} v2CredentialProtocol
 * @param {boolean} anoncreds
 * @param {boolean} anoncredsRs
 * @param {boolean} indyVdr
 * @param {boolean} mediationRecipient
 * @param {boolean} keyDidRegistrar
 * @param {boolean} jwkDidRegistrar
 * @param {boolean} webDidResolver
 * @param {boolean} keyDidResolver
 * @param {boolean} jwkDidResolver
 * @param {boolean} indyVdrIndyDidResolver
 * @param {boolean} indyVdrSovDidResolver
 * @param {boolean} useQuestionAnswer
 * @param {boolean} useSurvey
 * @param {boolean} useMediaSharing
 * @param {boolean} useUserProfile
 * @param {boolean} useBle
 * @param {boolean} useDrpc
 * @param {boolean} autoCreateLinkSecret
 * @param {boolean} useReceipts - https://didcomm.org/receipts/1.0/
 * @returns {Promise.<string>}
 */
export async function jsa_aries_agent_create(label, walletConfig_id, walletConfig_key, walletConfig_KeyDerivationMethod, walletConfig_storage, endpoints, publicDidSeed, connectToIndyLedgerOnStartup, logger, loglevel, didCommMimeType, autoAcceptCredentials, autoAcceptProofs, autoAcceptMediationRequests, mediationConnectionsInvitation, defaultMediatorId, clearDefaultMediator, mediatorPollingInterval, mediatorPickupStrategy, maximumMessagePickup, useLegacyDidSovPrefix, connectionImageUrl, autoUpdateStorageOnStartup, autoAcceptConnections, indyLedgers, useDidSovPrefixWhereAllowed, useDidKeyInProtocols, useModuleOpenId4VC, v1ProofProtocol, v2ProofProtocol, v1CredentialProtocol, v2CredentialProtocol, anoncreds, anoncredsRs, indyVdr, mediationRecipient, keyDidRegistrar, jwkDidRegistrar, webDidResolver, keyDidResolver, jwkDidResolver, indyVdrIndyDidResolver, indyVdrSovDidResolver, useQuestionAnswer, useSurvey, useMediaSharing, useUserProfile, useBle, useDrpc, autoCreateLinkSecret, useReceipts) {
	// BEGIN USER CODE
	try {
		//--------------------------------------------------------------------------------
		//Take care of empty strings - set to null
		//--------------------------------------------------------------------------------
		if(label == "") label = null;
		if(walletConfig_id == "") walletConfig_id = null;
		if(walletConfig_key == "") walletConfig_key = null;
		if(walletConfig_KeyDerivationMethod == "") walletConfig_KeyDerivationMethod = null;
		if(walletConfig_storage == "") walletConfig_storage = null;
		if(endpoints == "") endpoints = null;
		if(publicDidSeed == "") publicDidSeed = null;
		if(connectToIndyLedgerOnStartup == "") connectToIndyLedgerOnStartup = null;
		if(logger == "") logger = null;
		if(loglevel == "") loglevel = null;
		if(didCommMimeType == "") didCommMimeType = null;
		if(autoAcceptCredentials == "") autoAcceptCredentials = null;
		if(autoAcceptProofs == "") autoAcceptProofs = null;
		if(autoAcceptMediationRequests == "") autoAcceptMediationRequests = null;
		if(mediationConnectionsInvitation == "") mediationConnectionsInvitation = null;
		if(defaultMediatorId == "") defaultMediatorId = null;
		if(clearDefaultMediator == "") clearDefaultMediator = null;
		if(mediatorPollingInterval == "") mediatorPollingInterval = null;
		if(mediatorPickupStrategy == "") mediatorPickupStrategy = null;
		if(maximumMessagePickup == "") maximumMessagePickup = null;
		if(useLegacyDidSovPrefix == "") useLegacyDidSovPrefix = null;
		if(connectionImageUrl == "") connectionImageUrl = null;
		if(autoUpdateStorageOnStartup == "") autoUpdateStorageOnStartup = null;
		if(autoAcceptConnections == "") autoAcceptConnections = null;
		//--------------------------------------------------------------------------------
		//validate and prepare parameters - begin
		//--------------------------------------------------------------------------------
		if(label == null) return Promise.reject("Invalid label parameter");
		if(walletConfig_id == null) return Promise.reject("Invalid walletConfig_id parameter");
		if(walletConfig_key == null) return Promise.reject("Invalid walletConfig_key parameter");
		if(walletConfig_KeyDerivationMethod == null) walletConfig_KeyDerivationMethod = "Argon2IMod";
		switch(walletConfig_KeyDerivationMethod){
			case "Argon2IMod":
				walletConfig_KeyDerivationMethod = KeyDerivationMethod.Argon2IMod;
				break;
			case "Argon2Int":
				walletConfig_KeyDerivationMethod = KeyDerivationMethod.Argon2Int;
				break;
			case "Raw":
				walletConfig_KeyDerivationMethod = KeyDerivationMethod.Raw;
				break;
			default:
				return Promise.reject("Invalid walletConfig_KeyDerivationMethod parameter");
				break;
		}
		if (walletConfig_storage == null);
		if (endpoints == null);
		if (publicDidSeed == null);
		if (connectToIndyLedgerOnStartup == null);
		if (loglevel == null) loglevel = "off";
		switch (loglevel) {
			case "debug":
				loglevel = LogLevel.debug;
				break;
			case "error":
				loglevel = LogLevel.error;
				break;
			case "fatal":
				loglevel = LogLevel.fatal;
				break;
			case "info":
				loglevel = LogLevel.info;
				break;
			case "off":
				loglevel = LogLevel.off;
				break;
			case "test":
				loglevel = LogLevel.test;
				break;
			case "trace":
				loglevel = LogLevel.warn;
				break;
			case "warn":
				loglevel = LogLevel.warn;
				break;
			default:
				return Promise.reject("Invalid loglevel parameter");
				break;
		}
		if (logger == null) logger = "DefaultLogger";
		switch (logger) {
			case "Console":
				logger = new support.logging.ConsoleLogger(loglevel, label);
				break;
			case "DefaultLogger":
				logger = new ConsoleLogger(loglevel);
				break;
			default:
				return Promise.reject("Invalid logger parameter");
				break;
		}
		if (didCommMimeType == null) didCommMimeType = "v0";
		switch (didCommMimeType) {
			case "v0":
				didCommMimeType = DidCommMimeType.V0;
				break;
			case "v1":
				didCommMimeType = DidCommMimeType.V1;
				break;
			default:
				return Promise.reject("Invalid didCommMimeType parameter");
				break;
		}
		if (autoAcceptCredentials == null) autoAcceptCredentials = "Never";
		switch (autoAcceptCredentials) {
			case "Never":
				autoAcceptCredential_ = AutoAcceptCredential.Never;
				break;
			case "ContentApproved":
				autoAcceptCredential_ = AutoAcceptCredential.ContentApproved;
				break;
			case "Always":
				autoAcceptCredential_ = AutoAcceptCredential.Always;
				break;
			default:
				return Promise.reject("Invalid autoAcceptCredentials parameter");
				break;
		}
		if (autoAcceptProofs == null) autoAcceptProofs = "Never";
		switch (autoAcceptProofs) {
			case "Never":
				autoAcceptProofs = AutoAcceptProof.Never;
				break;
			case "ContentApproved":
				autoAcceptProofs = AutoAcceptProof.ContentApproved;
				break;
			case "Always":
				autoAcceptProofs = AutoAcceptProof.Always;
				break;
			default:
				return Promise.reject("Invalid autoAcceptProofs parameter");
				break;
		}
		if (autoAcceptMediationRequests == null);
		if (mediationConnectionsInvitation == null);
		if (defaultMediatorId == null);
		if (clearDefaultMediator == null) clearDefaultMediator = false;
		if (mediatorPollingInterval == null) mediatorPollingInterval = 5000;
		if (mediatorPickupStrategy == null);
		switch (mediatorPickupStrategy) {
			case "PickUpV1":
				mediatorPickupStrategy = MediatorPickupStrategy.PickUpV1;
				break;
			case "PickUpV2":
				mediatorPickupStrategy = MediatorPickupStrategy.PickUpV2;
				break;
			case "Implicit":
				mediatorPickupStrategy = MediatorPickupStrategy.Implicit;
				break;
			case "None":
				mediatorPickupStrategy = MediatorPickupStrategy.None;
				break;
			default:
				//return Promise.reject("Invalid mediatorPickupStrategy parameter");
				break;
		}
		if (maximumMessagePickup == null) maximumMessagePickup = 10;
		if (useLegacyDidSovPrefix == null) useLegacyDidSovPrefix = false;
		if (connectionImageUrl == null);
		if (autoUpdateStorageOnStartup == null) autoUpdateStorageOnStartup = false;
		if (autoAcceptConnections == null) autoAcceptConnections = false;
		if (indyLedgers != null) {
			try {
				indyLedgers = JSON.parse(indyLedgers);
				if (!Array.isArray(indyLedgers)) return Promise.reject("Parameter indyLedgers is not a JSON array");
			} catch (e) {
				return Promise.reject("Parameter indyLedgers is not a valid JSON array object");
			}
		} else {
			indyLedgers = [];
		}
		if (useDidSovPrefixWhereAllowed == null);
		if (useDidKeyInProtocols == null);
		/*
		//--------------------------------------------------------------------------------
		//validate and prepare parameters - end
		//--------------------------------------------------------------------------------
		//construct configuration parameter - begin
		//--------------------------------------------------------------------------------
		*/
		let config = {};
		if (label != null) config.label = label;
		if (
			walletConfig_KeyDerivationMethod != null ||
			walletConfig_id != null ||
			walletConfig_key != null ||
			walletConfig_storage
		) {
			let walletConfig = {};
			if (walletConfig_id != null) walletConfig.id = walletConfig_id;
			if (walletConfig_key != null) walletConfig.key = walletConfig_key;
			if (walletConfig_KeyDerivationMethod != null) walletConfig.keyDerivationMethod = walletConfig_KeyDerivationMethod;
			if (walletConfig_storage != null) walletConfig.storage = walletConfig_storage;
			config.walletConfig = walletConfig;
		} else {
			return Promise.reject("walletConfig parameters not specified");
		}
		if (endpoints != null) config.endpoints = JSON.parse(endpoints);
		if (publicDidSeed != null) config.publicDidSeed = publicDidSeed;
		if (didCommMimeType != null) config.didCommMimeType = didCommMimeType;
		if (autoAcceptCredentials != null) config.autoAcceptCredentials = autoAcceptCredentials;
		if (autoAcceptProofs != null) config.autoAcceptProofs = autoAcceptProofs;
		if (autoAcceptMediationRequests != null) config.autoAcceptMediationRequests = autoAcceptMediationRequests;
		if (defaultMediatorId != null && defaultMediatorId != "") config.defaultMediatorId = defaultMediatorId;
		if (clearDefaultMediator != null && clearDefaultMediator != false) config.clearDefaultMediator = clearDefaultMediator;
		if (mediatorPollingInterval != null) config.mediatorPollingInterval = mediatorPollingInterval;
		if (mediatorPickupStrategy != null) config.mediatorPickupStrategy = mediatorPickupStrategy;
		if (maximumMessagePickup != null) config.maximumMessagePickup = maximumMessagePickup;
		if (useLegacyDidSovPrefix != null && useLegacyDidSovPrefix != false) config.useLegacyDidSovPrefix = useLegacyDidSovPrefix;
		if (connectionImageUrl != null) config.connectionImageUrl = connectionImageUrl;
		if (autoUpdateStorageOnStartup != null && autoUpdateStorageOnStartup != false) config.autoUpdateStorageOnStartup = autoUpdateStorageOnStartup;
		if (autoAcceptConnections != null) config.autoAcceptConnections = autoAcceptConnections;
		if (connectToIndyLedgerOnStartup != null) config.connectToIndyLedgerOnStartup = connectToIndyLedgerOnStartup;
		if (logger != null) config.logger = logger;
		if (useDidSovPrefixWhereAllowed != null) config.useDidSovPrefixWhereAllowed = useDidSovPrefixWhereAllowed;
		if (useDidKeyInProtocols != null) config.useDidKeyInProtocols = useDidKeyInProtocols;
		//-----------------------------------------------------------------------------------
		const legacyIndyCredentialFormatService = new LegacyIndyCredentialFormatService()
		const legacyIndyProofFormatService = new LegacyIndyProofFormatService()
		//-----------------------------------------------------------------------------------
		let agentModules = {};
		//-----------------------------------------------------------------------------------
		try {
			agentModules.connections = new ConnectionsModule({
				autoAcceptConnections: autoAcceptConnections
			});
		} catch (e) {
			console.error("Failed to register ConnectionsModule:" + e.toString());
		}
		//-----------------------------------------------------------------------------------
		try {
			agentModules.askar = new AskarModule({
				ariesAskar: ariesAskar
			});
		} catch (e) {
			console.error("Failed to register AskarModule:" + e.toString());
		}
		//-----------------------------------------------------------------------------------
		let credentialProtocols = []
		if (v1CredentialProtocol) {
			try {
				credentialProtocols.push(
					new V1CredentialProtocol({
						indyCredentialFormat: legacyIndyCredentialFormatService,
					})
				);
			} catch (e) {
				console.error("Failed to register V1CredentialProtocol:" + e.toString());
			}
		}
		if (v2CredentialProtocol) {
			try {
				credentialProtocols.push(
					new V2CredentialProtocol({
						credentialFormats: [
							legacyIndyCredentialFormatService,
							new AnonCredsCredentialFormatService()
						]
					})
				);
			} catch (e) {
				console.error("Failed to register V2CredentialProtocol:" + e.toString());
			}
		}
		try {
			agentModules.credentials = new CredentialsModule({
				autoAcceptCredentials: autoAcceptCredential_,
				credentialProtocols: credentialProtocols
			});
		} catch (e) {
			console.error("Failed to register CredentialsModule:" + e.toString());
		}
		//-----------------------------------------------------------------------------------
		let proofProtocols = []
		if (v1ProofProtocol) {
			try {
				proofProtocols.push(
					new V1ProofProtocol({
						indyProofFormat: new LegacyIndyProofFormatService()//legacyIndyProofFormatService,
					})
				);
			} catch (e) {
				console.error("Failed to register V1ProofProtocol:" + e.toString());
			}
		}
		if (v2ProofProtocol) {
			try {
				proofProtocols.push(
					new V2ProofProtocol({
						proofFormats: [
							new LegacyIndyProofFormatService(),//legacyIndyProofFormatService,
							new AnonCredsProofFormatService()
						],
					})
				);
			} catch (e) {
				console.error("Failed to register V2ProofProtocol:" + e.toString());
			}
		}
		try {
			agentModules.proofs = new ProofsModule({
				autoAcceptProofs: autoAcceptProofs,
				proofProtocols: proofProtocols
			});
		} catch (e) {
			console.error("Failed to register ProofsModule:" + e.toString());
		}
		//-----------------------------------------------------------------------------------
		if (anoncreds) {
			try {
				agentModules.anoncreds = new AnonCredsModule({
					//todo:add configurability or turn cheqd off based on main cheqd enabling parameter
					registries: [
						new IndyVdrAnonCredsRegistry(),
						//16:15 2024/05/03
						new DidWebAnonCredsRegistry()
					],
					autoCreateLinkSecret:autoCreateLinkSecret,//21:04 2024/10/07 - added
					anoncreds //15:52 2024/04/30 - added
				});
			} catch (e) {
				console.error("Failed to register AnonCredsModule:" + e.toString());
			}
		}
		//-----------------------------------------------------------------------------------
		if (indyVdr) {
			try {
				agentModules.indyVdr = new IndyVdrModule({
					indyVdr,
					//compare with
					//https://github.com/animo/paradym-wallet/blob/0eed5477ad704e851c52e1b7ccc68d92df31fd9f/packages/agent/src/agent.ts#L29
					networks: indyLedgers == null ? [] : indyLedgers,
				});
			} catch (e) {
				console.error("Failed to register IndyVdrModule:" + e.toString());
			}
		}
		//-----------------------------------------------------------------------------------
		let dids_registrars = [];
		//if(indySdkIndyDidRegistrar){
		//	dids_registrars.push(new IndySdkIndyDidRegistrar());
		//}
		if (keyDidRegistrar) {
			try {
				dids_registrars.push(new KeyDidRegistrar());
			} catch (e) {
				console.error("Failed to register KeyDidRegistrar:" + e.toString());
			}
		}
		if (jwkDidRegistrar) {
			try {
				dids_registrars.push(new JwkDidRegistrar());
			} catch (e) {
				console.error("Failed to register JwkDidRegistrar:" + e.toString());
			}
		}
		//-----------------------------------------------------------------------------------
		let dids_resolvers = [];
		if (webDidResolver) {
			try {
				dids_resolvers.push(new WebDidResolver());
			} catch (e) {
				console.error("Failed to register WebDidResolver:" + e.toString());
			}
		}
		if (keyDidResolver) {
			try {
				dids_resolvers.push(new KeyDidResolver());
			} catch (e) {
				console.error("Failed to register KeyDidResolver:" + e.toString());
			}
		}
		if (jwkDidResolver) {
			try {
				dids_resolvers.push(new JwkDidResolver());
			} catch (e) {
				console.error("Failed to register JwkDidResolver:" + e.toString());
			}
		}
		if (indyVdrSovDidResolver) {
			try {
				dids_resolvers.push(new IndyVdrSovDidResolver());
			} catch (e) {
				console.error("Failed to register IndyVdrSovDidResolver:" + e.toString());
			}
		}
		if (indyVdrIndyDidResolver) {
			try {
				dids_resolvers.push(new IndyVdrIndyDidResolver());
			} catch (e) {
				console.error("Failed to register IndyVdrIndyDidResolver:" + e.toString());
			}
		}
		try {
			//if(indySdkSovDidResolver){
			//	dids_resolvers.push(new IndySdkSovDidResolver());
			//}
			//if(indySdkIndyDidResolver){
			//	dids_resolvers.push(new IndySdkIndyDidResolver());
			//}
			//if(indyVdrSovDidResolver){
			//	dids_resolvers.push(new IndyVdrSovDidResolver());
			//}
			//if(indyVdrIndyDidResolver){
			//	dids_resolvers.push(new IndyVdrIndyDidResolver());
			//}
			agentModules.dids = new DidsModule({
				registrars: dids_registrars,
				resolvers: dids_resolvers
			});
		} catch (e) {
			console.error("Failed to register DidsModule:" + e.toString());
		}
		//-----------------------------------------------------------------------------------
		if (useModuleOpenId4VC) {
			try {
				agentModules.openId4VcHolder = new OpenId4VcHolderModule();
			} catch (e) {
				console.error("Failed to register OpenId4VcHolderModule:" + e.toString());
			}
		}
		//-----------------------------------------------------------------------------------
		if (mediationRecipient) {
			try {
				agentModules.mediationRecipient = new MediationRecipientModule((mediationConnectionsInvitation != null) ? ({
					mediatorInvitationUrl: mediationConnectionsInvitation
					//todo:mediatorPickupStrategy: MediatorPickupStrategy.X,
				}) : ({}));
			} catch (e) {
				console.error("Failed to register MediationRecipientModule:" + e.toString());
			}
		}
		if (useQuestionAnswer) {
			try {
				agentModules.questionAnswer = new QuestionAnswerModule();
			} catch (e) {
				console.error("Failed to register QuestionAnswerModule:" + e.toString());
			}
		}
		if (useDrpc) {
			try {
				agentModules.drpc = new DrpcModule();
			} catch (e) {
				console.error("Failed to register DRPCModule:" + e.toString());
			}
		}
		if (useSurvey) {
			try {
				agentModules.survey = new SurveyModule();
			} catch (e) {
				console.error("Failed to register SurveyModule:" + e.toString());
			}
		}
		//-----------------------------------------------------------------------------------
		if (useUserProfile) {
			try {
				agentModules.userProfile = new UserProfileModule();
			} catch (e) {
				console.error("Failed to register UserProfileModule:" + e.toString());
			}
		}
		if (useMediaSharing) {
			try {
				agentModules.media = new MediaSharingModule();
			} catch (e) {
				console.error("Failed to register MediaSharingModule:" + e.toString());
			}
		}
		if (useReceipts) {
			try {
				agentModules.receipts = new ReceiptsModule();
				//console.info("Calling ReceiptsModule()");
				//new ReceiptsModule();
				//console.info(typeof(ReceiptsModule));
			} catch (e) {
				console.error("Failed to register ReceiptsModule: " + e.toString());
			}
		}
		//-----------------------------------------------------------------------------------
		/*
		if (useBle) {
			try {
				//
			} catch (e) {
				console.error(e.toString());
			}
		}
		*/
		//-----------------------------------------------------------------------------------
		const agent = new Agent({
			config,
			dependencies: agentDependencies,
			modules: agentModules,
		});
		
		
		return Promise.resolve(support.cache.put(agent, walletConfig_id));
		
	} catch (e) {
		return Promise.reject(e.toString());
	}
	// END USER CODE
}
