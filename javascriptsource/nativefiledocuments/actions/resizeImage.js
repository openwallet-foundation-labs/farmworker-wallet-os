// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import "mx-global";
import { Big } from "big.js";

// BEGIN EXTRA CODE

import ImageResizer from 'react-native-image-resizer';
import NativeFileDocumentsUtils from "../nativefiledocumentsutils";
import RNFS from "react-native-fs";
import { Platform } from 'react-native';

// END EXTRA CODE

/**
 * Resize an image using the specified parameters to a new file or base64 encoded image data.
 * @param {string} filepath - The path to the file.
 * @param {"NativeFileDocuments.PathType.FullPath"|"NativeFileDocuments.PathType.DocumentsDirectory"} pathType
 * @param {Big} maxWidth
 * @param {Big} maxHeight
 * @param {"NativeFileDocuments.ResizeImageCompressionFormat.JPEG"|"NativeFileDocuments.ResizeImageCompressionFormat.PNG"|"NativeFileDocuments.ResizeImageCompressionFormat.WEBP"} compressFormat - Can be either JPEG, PNG or WEBP (android only).
 * @param {Big} quality - A number between 0 and 100. Used for the JPEG compression.
 * @param {Big} rotation - Rotation to apply to the image, in degrees, for android. On iOS, rotation is limited (and rounded) to multiples of 90 degrees. Specify 0 for no rotation.
 * @param {boolean} keepMeta - If true, will attempt to preserve all file metadata/exif info, except the orientation value since the resizing also does rotation correction to the original image. Defaults to false, which means all metadata is lost. Note: This can only be true for JPEG images.
 * @param {"NativeFileDocuments.ResizeImageMode.contain"|"NativeFileDocuments.ResizeImageMode.cover"|"NativeFileDocuments.ResizeImageMode.stretch"} resizeMode - Resize mode, either contain, cover, or stretch. contain will fit the image within width and height, preserving its ratio. cover preserves the aspect ratio, and makes sure the image is at least width wide or height tall. stretch will resize the image to exactly width and height.
 * @param {boolean} onlyScaleDown - If true, will never enlarge the image, and will only make it smaller.
 * @param {boolean} writeToLog
 * @returns {Promise.<MxObject>}
 */
export async function resizeImage(filepath, pathType, maxWidth, maxHeight, compressFormat, quality, rotation, keepMeta, resizeMode, onlyScaleDown, writeToLog) {
	// BEGIN USER CODE

	return new Promise(function (resolve, reject) {
		if (!filepath) {
			reject(new Error("No file path specified"));
		}

		if (!pathType) {
			reject(new Error("No path type specified"));
		}

		if (!maxWidth) {
			reject(new Error("No maximum width specified"));
		}
		const maxWidthValue = Number(maxWidth);
		if (maxWidthValue < 0) {
			reject(new Error("Invalid maximum width: must be positive"));
		}

		if (!maxHeight) {
			reject(new Error("No maximum height specified"));
		}
		const maxHeightValue = Number(maxHeight);
		if (maxHeightValue < 0) {
			reject(new Error("Invalid maximum height: must be positive"));
		}

		if (!compressFormat) {
			reject(new Error("No compression format specified"));
		}

		if (!quality) {
			reject(new Error("No quality specified"));
		}
		const qualityValue = Number(quality);
		if (qualityValue < 0 || qualityValue > 100) {
			reject(new Error("Invalid quality value: must be between 0 and 100"));
		}

		if (!rotation) {
			reject(new Error("No rotation specified"));
		}
		const rotationValue = Number(rotation);
		if (rotationValue < 0) {
			reject(new Error("Invalid rotation: must be positive"));
		}

		if (!resizeMode) {
			reject(new Error("No resize mode specified"));
		}

		if (writeToLog) {
			NativeFileDocumentsUtils.writeToLog({
				actionName: "resizeImage",
				logType: "Parameters",
				logMessage: JSON.stringify({
					filepath: filepath,
					pathType: pathType,
					maxWidth: maxWidthValue,
					maxHeight: maxHeightValue,
					compressFormat: compressFormat,
					quality: qualityValue,
					rotation: rotationValue,
					resizeMode: resizeMode
				})
			});
		}

		const fullPath = NativeFileDocumentsUtils.getFullPathNoPrefix(filepath, pathType, RNFS, Platform.OS);

		if (writeToLog) {
			NativeFileDocumentsUtils.writeToLog({
				actionName: "resizeImage",
				logType: "Info",
				logMessage: "Full path: " + fullPath
			});
		}

		const slashPos = fullPath.lastIndexOf("/");
		const outputPath = fullPath.substring(0, slashPos + 1);

		if (writeToLog) {
			NativeFileDocumentsUtils.writeToLog({
				actionName: "resizeImage",
				logType: "Info",
				logMessage: "Output path: " + outputPath
			});
		}

		const options = {
			mode: resizeMode,
			onlyScaleDown: onlyScaleDown
		};

		ImageResizer.createResizedImage(
			fullPath,
			maxWidthValue,
			maxHeightValue,
			compressFormat,
			qualityValue,
			rotationValue,
			outputPath,
			keepMeta,
			options
		).then(resizedImageData => {
			if (writeToLog) {
				NativeFileDocumentsUtils.writeToLog({
					actionName: "resizeImage",
					logType: "Info",
					logMessage: JSON.stringify(resizedImageData)
				});
			}
			NativeFileDocumentsUtils.createMxObject("NativeFileDocuments.ResizeImageResult").then(resultMxObj => {
				resultMxObj.set("ResizedWidth", resizedImageData.width);
				resultMxObj.set("ResizedHeight", resizedImageData.height);
				resultMxObj.set("Name", resizedImageData.name);
				resultMxObj.set("FilePath", resizedImageData.path);
				resolve(resultMxObj);
			});
		}).catch(error => {
			// If this fails, always write a log entry
			NativeFileDocumentsUtils.writeToLog({
				actionName: "resizeImage",
				logType: "Exception",
				logMessage: JSON.stringify(error)
			});
			reject(error)
		});

	});
	// END USER CODE
}
